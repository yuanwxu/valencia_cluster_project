---
title: "Study of TB transmission clusters in Valencia"
author: "Yuanwei Xu"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Joint transmission framework

We extend the `TransPhylo` package so we could handle multiple transmission clusters simultaneously, with the possiblity of sharing parameters across clusters. Now, we apply this inference framework to cluster data from a TB outbreak in Valencia between 2014 and 2016.

## Case study --- TB transmission clusters in Valencia

First, we extract from the phylogenetic tree (obtained from FASTTREE) the clades corresponding to 20 clustes in the estimated transmission network. 

We plot the big phylogenetic tree which includes all sequence isolates.

```{r extract_clade}
library(ape)
bigtree <- read.tree("Data/new/genome_epi_val_all_isolates_201416.tree")
plot(bigtree, cex = 0.4)

```

Then define some helper functions that helps us extract interesting clades from the big tree.

```{r}
# Given cluster name, return all case labels except MLRA
get_cluster_tiplabel <- function(path = ".", name){
  dna <- read.dna(paste0(path,"run_alignment_", name, ".fas"), format = "fasta")
  rownames(dna)[rownames(dna) != "MLRA"]
}

# Get clade on the big tree that corresponds to a given cluster
# Adapted from Michelle's MRCA_of_interesting_tips.R
extract_clade_cluster <- function(tree, cluster_tips){
  if(!all(cluster_tips %in% tree$tip.label))
    warning("Not all interesting tips exist in the big tree")
  
  l <- length(tree$tip.label)
  # get the numbers of the internal nodes of the tree
  intNodes <- (l+1):(l+tree$Nnode)
  # for each internal node, find its descendants:
  descs <- phangorn::Descendants(tree, node=intNodes, type="tips")
  # Find number of common tips between given cluster and each of the internal node's tips 
  num_common_tips <- sapply(intNodes, function(x) {
    sum(which(tree$tip.label %in% cluster_tips) %in% descs[[x-l]])
  })
  
  ind_max <- which(num_common_tips == max(num_common_tips))
  out <- vector("integer", length(ind_max))
  # Choose the smallest clade that contains all interesting tips
  j <- 1
  for(i in ind_max){
    out[j] <- length(extract.clade(tree, i+l)$tip.label)
    j <- j + 1
  }
  extract.clade(tree, ind_max[which.min(out)] + l)
}
```

Certain tips in some clusters have unusual cryptic names, these will be corrected.

```{r, message=FALSE}
library(tidyverse)
names_cl <- c(paste0("CL00", c(5,7,8,9)), paste0("CL0", c(10,11,16,20:26,31,34,39,45,50,62)))
tiplabel_cl <- map(names_cl, get_cluster_tiplabel, path = "Data/new/")

# Sanity check 
# Do all tips have format "G" followed by 2-4 digits and nothing else?
tiplabel_cl[map_lgl(tiplabel_cl, ~ any(!str_detect(.x, "^G\\d{2,4}$")))]
#
# What about tips on the big tree?
bigtree$tip.label[!str_detect(bigtree$tip.label, "^G\\d{2,4}$")]
# Correct unusual tips
tiplabel_cl[[4]][2] <- "G788"
tiplabel_cl[[16]][1] <- "G1238"

tree_cl <- map(tiplabel_cl, extract_clade_cluster, tree = bigtree)
```


We have extracted clades of 20 clusters from the big tree. Together with the dates on the tips, we can estimate the clock rate and rescale the branches, using the R package `treedater`. We then run joint transmission inference on these timed trees.

To prepare input to `treedater`, we take the helper function `get_sts2Treedater` from an earlier analysis, and define a new helper function `read_epidata` to read multiple epi data files.

```{r}
get_sts2Treedater <- function(epi_info, tre){
  sts <- epi_info %>%
    select(`Isolate ID`, `Diagnosis date`) %>% 
    mutate(`Isolate ID` = paste0("G", `Isolate ID`),
           `Diagnosis date` = lubridate::decimal_date(`Diagnosis date`))
  
  tips_no_match <- dplyr::setdiff(tre$tip.label, sts$`Isolate ID`)
  if(length(tips_no_match) > 0) warning("Found tips on the tree that are missing in epi data")
  
  num_tips <- length(tre$tip.label)
  sts2 <- set_names(rep(NA, num_tips), tre$tip.label)
  sts2[sts$`Isolate ID`] <- sts$`Diagnosis date`

  if(length(tips_no_match) != sum(is.na(sts2)))
    warning("There is record in epi data but the date field is missing.")
    
  if(length(tips_no_match) > 0)
    return(list(sts=sts2, tips_no_match=tips_no_match))
  else
    return(list(sts=sts2))
}

read_epidata <- function(path = ".", locate.file = TRUE, pattern = NULL, fnames = NULL){
  if(locate.file){
    if(is.null(pattern))
      stop("You must provide regex to look up files with.")
    f <- list.files(path, pattern, full.names = TRUE)
    map(f, readxl::read_excel)
  }
  else {
    if(is.null(fnames))
      stop("You must provide file names.")
    map(paste0(path, fnames), readxl::read_excel)
  }
}  
```


Once we have read in all the epi data, we then attach the dates to the corresponding tips, but keep in mind that not all dates are known and we may have to supply uncertainty bounds to those tips whose dates were missing. 

```{r}
epi_cl <- read_epidata("Data/new/", locate.file = FALSE, fnames = paste0("epi_info_", names_cl, ".xlsx"))
sts_cl <- map2(epi_cl, tree_cl, get_sts2Treedater)

# Which clusters have missing dates?
which(map_lgl(sts_cl, ~ anyNA(.$sts)))
names_cl[which(map_lgl(sts_cl, ~ anyNA(.$sts)))]
```

Here we check where those cases are in the provided transmission network, and use the average of the nearby cases' diagnosis times as the midpoints of the bounds. The widths of these bounds are chosen to be 1 year. These can all be changed according to what we know about those cases, or even omitted from the analysis if we are unsure.

```{r fix_missing}
sts_cl[[1]] <- within(sts_cl[[1]], sts[tips_no_match] <- mean(sts[c("G679","G114","G1330")]))
sts_cl[[5]] <- within(sts_cl[[5]], sts[tips_no_match] <- mean(sts[c("G405","G1180","G1181","G1965","G1446")]))
sts_cl[[14]] <- within(sts_cl[[14]], sts[tips_no_match] <- mean(sts[c("G1829","G1792","G147")]))

add_uncertainty_bounds <- function(sts, b = 0.5){
  for (i in seq_along(sts)) {
    if(exists("tips_no_match", where = sts[[i]])){
      sts[[i]]$sts_df <- with(sts[[i]], data.frame(lower = sts[tips_no_match] - b, 
                                                 upper = sts[tips_no_match] + b,
                                                 row.names = tips_no_match))
    }
  }
  sts
}

sts_cl <- add_uncertainty_bounds(sts_cl)
```

With all the necessary input, we run `treedater` to date the trees, using strict molecular clock and uncertainty bounds for tips with unknown dates. **Note for illustration purpose we remove the clusters that `treedater` complains, it is not sure how to deal with them unless we get more information about the original phylogeny such as units of branch lengths, etc** As `TransPhylo` has to take in positive branch lengths, we again use the strategy of shifting the near-zero branch lengths by a small constant. The end result is a list of timed trees of class `phylo` that can be converted into the format to run `TransPhylo` with.

```{r get_timed_tree, message=FALSE}
library(treedater)
tdaterAnalysis <- function(tre, sts, sqlen, ...){
  stopifnot(length(tre) == length(sts))
  out <- vector("list", length(tre))
  for (i in seq_along(sts)) {
    if(exists("tips_no_match", where = sts[[i]])){
      out[[i]] <- dater(tre[[i]], sts[[i]]$sts, sqlen, estimateSampleTimes = sts[[i]]$sts_df, ...)
    }
    else{
      out[[i]] <- dater(tre[[i]], sts[[i]]$sts, sqlen, ...)
    }
  }
 out
}

# treedater gives warnings for some clusters, need to come up with a method to deal with this.
# Now for illustrative purpose omit these clusters
dater_warning_index <- c(3,4,6,7,8,13,15:18)
timed_tree_cl <- tdaterAnalysis(tree_cl[-dater_warning_index], sts_cl[-dater_warning_index], 4411532, strictClock = TRUE)

# Fix near-zero branch lengths of timed trees
fix_edge_length <- function(timed_tree){
  map(timed_tree, function(x) {x$edge.length[dplyr::near(x$edge.length,0)] <- 0.1; x})
}
timed_tree_cl <- fix_edge_length(timed_tree_cl)
```


We apply the new routine `infer_multiTTree_shareParam` to the list of timed trees corresponding to clusters `r names_cl[-dater_warning_index]`, 
sharing all parameters.

```{r transphylo_run, results="hide"}
library(TransPhylo)
date_last_cl <- map(timed_tree_cl, ~ max(.$sts))
ptree_cl <- map2(timed_tree_cl, date_last_cl, ptreeFromPhylo)

# The following is used temporarily and will be removed when pushed upstream to TransPhylo repo or when incorporated into a new package.
source("~/Biomath/TransPhylo/R/proposal.R")
source("~/Biomath/TransPhylo/R/computeHost.R")
source("~/Biomath/TransPhylo/R/infer_multiTTree_shareParam.R")

ws.shape <- 1.1; ws.scale <- 1/0.4
w.shape <- 1.3; w.scale <- 1/0.3
iters <- 2e4; thin <- 10
set.seed(1)
record_cl <- infer_multiTTree_shareParam(ptree_cl, w.shape, w.scale, ws.shape, ws.scale, 
                                      mcmcIterations = iters, thinning = thin, 
                                      share = c("neg","off.r","off.p","pi"))

# Disgard burnin 
discard_burnin <- function(record_lst, burnin = 0.2){
  map(record_lst, function(x) x[round(length(x)*burnin):length(x)])
}
record_small_cl <- discard_burnin(record_cl)
rm(record_cl)

# Simple trace plot of shared parameters
par(mfrow = c(1,3))
plot(map_dbl(record_small_cl[[1]], "neg"), type = "l", ylab = "neg", xlab = "MCMC step")
plot(map_dbl(record_small_cl[[1]], "off.r"), type = "l", ylab = "off.r", xlab = "MCMC step")
plot(map_dbl(record_small_cl[[1]], "pi"), type = "l", ylab = "pi", xlab = "MCMC step")

```

We compute the probability of sampled index case for each individual cluster.

```{r unsamp_index_case}
prob_samp_src <- function(record){
  probs <- vector("double", length(record))
  for(i in seq_along(record)){
    tt <- extractTTree(record[[i]]$ctree)$ttree
    src_ind <- which(tt[,3] == 0)
    probs[i] <- !is.na(tt[src_ind, 2])
  }
  mean(probs)
}

tibble(cluster = names_cl[-dater_warning_index], 
       sampled = map_dbl(record_small_cl, prob_samp_src),
       unsampled = 1 - sampled) %>%
  gather(index_case, prob, sampled:unsampled) %>%
  ggplot(aes(cluster, prob)) + 
  geom_col(aes(fill = index_case), width = 0.5) +
  coord_flip()
```

Show detailed breakdown of source case distribution. 

```{r}
# Source case distribution 
get_src_case_distribution <- function(record){
  table(map_chr(record, "source"))/length(record)
}

map(record_small_cl, get_src_case_distribution) %>%
  set_names(names_cl[-dater_warning_index])
```


Show the most representative trees from the posterior.

```{r}
# Most representative trees 
# https://github.com/xavierdidelot/TransPhylo/blob/master/R/selectTTree.R
source("~/Biomath/TransPhylo/R/selectTTree/selectTTree.R")
rpttree_cl <- map_dbl(record_small_cl, selectTTree, burnin = 0)
par(mfrow = c(5,2))
par(mar=c(1,1,1,1))
for(k in 1:length(record_small_cl))
  plotTTree2(extractTTree(record_small_cl[[k]][[rpttree_cl[k]]]$ctree))

```

Show for each cluster the distribution of the number of unsampled cases.

```{r}
get_num_unsampled <- function(record){
  tt <- map(record, ~ extractTTree(.$ctree)$ttree)
  map_dbl(tt, ~ sum(is.na(.[, 2])))
} 

unsampled_count_cl <- sapply(record_small_cl, get_num_unsampled)
colnames(unsampled_count_cl) <- names_cl[-dater_warning_index]
as_tibble(unsampled_count_cl) %>% 
  gather(cluster, num_unsampled) %>% 
  ggplot(aes(num_unsampled)) + geom_bar() + facet_wrap(~cluster, nrow = 5)
```

Show for each cluster the distribution of infection time of the index case.

```{r}
get_inftime_index_case <- function(record){
  map_dbl(record, function(x){
    tt <- extractTTree(x$ctree)$ttree
    k <- which(tt[,3] == 0)
    tt[k, 1]
  })
}

inftime_cl <- sapply(record_small_cl, get_inftime_index_case)
colnames(inftime_cl) <- names_cl[-dater_warning_index]
as_tibble(inftime_cl) %>% 
  gather(cluster, inftime_index_case) %>% 
  ggplot(aes(inftime_index_case)) + 
  geom_histogram(bins = 40) + 
  scale_x_continuous(breaks = scales::pretty_breaks(10)) +
  facet_wrap(~cluster, nrow = 5) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

